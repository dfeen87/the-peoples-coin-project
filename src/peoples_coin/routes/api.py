import http
import logging
from functools import wraps

from flask import Blueprint, request, jsonify, g
from pydantic import BaseModel, ValidationError
from sqlalchemy.exc import IntegrityError

from peoples_coin.extensions import db
from peoples_coin.utils.auth import require_firebase_token
from peoples_coin.models import UserAccount, UserWallet # 1. Import UserWallet as well

logger = logging.getLogger(__name__)

# Renamed blueprint and removed the url_prefix.
user_api_bp = Blueprint("user_api", __name__)


# --- User-related Routes ---

@user_api_bp.route("/users/username-check/<username>", methods=["GET"])
def check_username_availability(username):
    """Checks if a username is available in the database."""
    logger.info(f"Checking database for username availability for: {username}")
    try:
        user_exists = db.session.query(UserAccount).filter(UserAccount.username.ilike(username)).first()
        is_available = (user_exists is None)
        logger.info(f"Username '{username}' is available: {is_available}")
        return jsonify({"available": is_available}), http.HTTPStatus.OK
    except Exception as e:
        logger.error(f"Database error while checking username '{username}': {e}", exc_info=True)
        return jsonify({"available": False, "error": "Database query failed"}), http.HTTPStatus.INTERNAL_SERVER_ERROR


# --- THIS IS THE FULLY WORKING, SCHEMA-AWARE REGISTRATION FUNCTION ---
@user_api_bp.route("/users/register-wallet", methods=["POST"])
@require_firebase_token
def register_user_wallet():
    """
    Creates a new UserAccount and a linked UserWallet in the database,
    based on the authenticated Firebase user.
    """
    firebase_user = g.firebase_user
    logger.info(f"Attempting to register new user and wallet for Firebase UID: {firebase_user['uid']}")

    try:
        data = request.get_json()
        if not data:
            return jsonify(error="Missing JSON body"), http.HTTPStatus.BAD_REQUEST

        username = data.get('username')
        public_key = data.get('public_key')
        encrypted_private_key = data.get('encrypted_private_key')

        if not all([username, public_key, encrypted_private_key]):
            return jsonify(error="Missing required fields: username, public_key, or encrypted_private_key"), http.HTTPStatus.BAD_REQUEST

        # 2. Create the main UserAccount record first.
        # Note: The primary key `id` is a UUID generated by default.
        new_user = UserAccount(
            firebase_uid=firebase_user['uid'],
            email=firebase_user['email'],
            username=username,
        )
        db.session.add(new_user)
        # We need to flush to get the generated UUID for the new_user.id
        db.session.flush()

        # 3. Now, create the UserWallet record, linking it to the new user.
        new_wallet = UserWallet(
            user_id=new_user.id, # Link using the generated UUID
            public_address=public_key,
            encrypted_private_key=encrypted_private_key,
            is_primary=True # Mark this as the user's primary wallet
        )
        db.session.add(new_wallet)

        # 4. Commit both new records to the database in a single transaction.
        db.session.commit()

        logger.info(f"Successfully created user and wallet for {username} ({firebase_user['uid']})")
        # You can decide what to return. Returning the user's profile is a good practice.
        return jsonify({"message": "User and wallet created successfully", "userId": str(new_user.id)}), http.HTTPStatus.CREATED

    except IntegrityError as e:
        db.session.rollback()
        logger.warning(f"Integrity error for UID {firebase_user['uid']} or username {username}. User may already exist. Details: {e}")
        return jsonify(error="User with this email, UID, or username already exists."), http.HTTPStatus.CONFLICT
    except Exception as e:
        db.session.rollback()
        logger.error(f"Failed to register user wallet for UID {firebase_user['uid']}: {e}", exc_info=True)
        return jsonify(error="An internal server occurred."), http.HTTPStatus.INTERNAL_SERVER_ERROR


@user_api_bp.route("/profile", methods=["GET"])
@require_firebase_token
def get_user_profile():
    """Returns the authenticated user's profile information."""
    # This assumes your require_firebase_token decorator finds the UserAccount
    # based on the firebase UID and attaches it to g.user
    user = g.user
    if not user:
        return jsonify(error="User not authenticated or found in local database"), http.HTTPStatus.UNAUTHORIZED
    # You will likely need a to_dict() method on your UserAccount model
    # to serialize it to JSON correctly.
    return jsonify(user.to_dict()), http.HTTPStatus.OK

